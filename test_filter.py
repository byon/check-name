# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

import filter
import os.path
import pytest


def test_without_options_node_should_not_be_filtered(tester):
    assert tester.test('path') is False


def test_node_not_in_include_directory_should_be_filtered(tester):
    assert tester.with_include_directory('a').test('b/file.cpp') is True


def test_node_in_include_directory_should_not_be_filtered(tester):
    assert tester.with_include_directory('a').test('a/file.cpp') is False


def test_multiple_include_directories_should_be_considered(tester):
    tester.with_include_directory('a').with_include_directory('b')
    assert tester.test('b/file.cpp') is False


def test_exclude_directories_should_be_filtered(tester):
    tester.with_include_directory('a').with_exclude_directory('a/b')
    assert tester.test('a/b/file.cpp') is True


def test_directory_is_in_itself():
    assert filter._is_in_directory('a', 'a') is True


def test_unrelated_path_is_not_in_directory():
    assert filter._is_in_directory('b', 'a') is False


def test_path_in_root_is_in_directory():
    assert filter._is_in_directory('a/file', 'a') is True


def test_path_in_sub_directory_is_in_directory():
    assert filter._is_in_directory('a/b/c/d/e/f/file', 'a') is True


def test_path_is_in_sub_directory_when_common_multiple_levels():
    assert filter._is_in_directory('a/b/c/d/e/f/file', 'a/b/c/d') is True


def test_forward_slashes_are_allowed_in_checking_directory():
    assert filter._is_in_directory('a/file', 'a/') is True


def test_backward_slashes_are_allowed_in_checking_directory():
    assert filter._is_in_directory('a\\file', 'a\\') is True


def test_mixed_slashes_are_allowed_in_checking_directory():
    assert filter._is_in_directory('a\\b/file', 'a\\b/') is True


def test_directory_and_path_can_have_different_os_styles():
    assert filter._is_in_directory('a\\b\\file', 'a/b/') is True


def test_absolute_directory_can_be_checked_with_relative_path():
    directory = os.path.abspath('a/b')
    assert filter._is_in_directory('a/b/file', directory) is True


def test_absolute_path_can_be_checked_with_relative_directory():
    path = os.path.abspath('a/b/file')
    assert filter._is_in_directory(path, 'a/b') is True


def test_relative_paths_are_normalized():
    directory = '../check-name/a/b/file'
    assert filter._is_in_directory(directory, 'a/../a/b') is True


@pytest.fixture
def tester(request):
    return _Tester()


class _Tester:
    def __init__(self):
        self.include_directories = []
        self.exclude_directories = []

    def with_include_directory(self, directory):
        self.include_directories.append(directory)
        return self

    def with_exclude_directory(self, directory):
        self.exclude_directories.append(directory)
        return self

    def test(self, path):
        filtering_options = (self.include_directories,
                             self.exclude_directories)
        return filter.should_filter(filtering_options, path)
