C++ naming analyser for style used in my workplace. Just started, so don't expect this to be useful.

Implemented by using python bindings to libclang. So far tested only on Linux.

NOTE: Currently requires minor modifications to the libclang python bindings, as they do not properly expose functionality for checking if method is virtual or pure virtual. The changes are minor to bindings/python/clang/cindex.py (I'll have to see, if I bother to ask for an official fix):
#+BEGIN_SRC Python
+    def is_pure_virtual_method(self):
+        return conf.lib.clang_CXXMethod_isPureVirtual(self)
+
+    def is_virtual_method(self):
+        return conf.lib.clang_CXXMethod_isVirtual(self)
+
#+END_SRC


** Running the analyser

Requires that python bindings to libclang are in PYTHONPATH. E.g.
#+BEGIN_EXAMPLE
$ export PYTHONPATH=../vendor/llvm/tools/clang/bindings/python/
#+END_EXAMPLE

The path to the LLVM dynamic library is required as --llvm_path option. The file to be analysed is passed as --target option. E.g.

#+BEGIN_EXAMPLE
$ ./check_name.py --llvm_path ../vendor/llvm/build/Release/lib --target foo.cpp
#+END_EXAMPLE

The rest of the options are passed to LLVM (e.g. include paths, preprocessor defines, etc.). Run check_name.py --help for more information.

** Testing

Unit tests use pytest, so just:
#+BEGIN_EXAMPLE
$ py.test
#+END_EXAMPLE

Higher level tests are implemented using behave. They require that you have defined path to the LLVM dynamic library location as LLVM_PATH environment variable. After that you can run behave.

#+BEGIN_EXAMPLE
$ export LLVM_PATH=/home/byon/src/vendor/llvm/build/Release/lib
$ behave
#+END_EXAMPLE
