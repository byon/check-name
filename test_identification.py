# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from clang.cindex import CursorKind, TypeKind
import pytest
from mock import MagicMock
from identification import (is_array, is_interface_class,
                            is_name_for_smart_pointer, is_pointer)


def test_node_is_interface_with_only_pure_virtual_methods(interface_tester):
    assert True == interface_tester.with_pure_virtual_method().test()


def test_node_is_not_interface_without_children(interface_tester):
    assert False == interface_tester.test()


def test_node_is_not_interface_without_methods(interface_tester):
    assert False == interface_tester.with_unknown().test()


def test_node_is_not_interface_with_unvirtual_methods(interface_tester):
    assert False == interface_tester.with_method().test()


def test_pointer_is_identified_as_pointer(pointer_tester):
    assert True == pointer_tester.with_type(TypeKind.POINTER).test()


def test_not_pointer_is_not_identified_as_pointer(pointer_tester):
    assert False == pointer_tester.with_type(TypeKind.INVALID).test()


def test_member_pointer_is_identified_as_pointer(pointer_tester):
    assert True == pointer_tester.with_type(TypeKind.MEMBERPOINTER).test()


def test_array_pointer_is_identified_as_pointer(pointer_tester):
    assert True == pointer_tester.with_type(TypeKind.CONSTANTARRAY).test()


def test_variable_whose_type_ends_ptr_is_identified_as_pointer(pointer_tester):
    assert True == pointer_tester.with_smart_pointer_variable().test()


def test_typedef_smart_pointer_variable_is_identified_as_pointer(
        pointer_tester):
    assert True == pointer_tester.with_typedef_smart_pointer_variable().test()


def test_array_is_identified_as_array(array_tester):
    assert True == array_tester.with_type(TypeKind.CONSTANTARRAY).test()


def test_not_array_is_not_identified_as_array(array_tester):
    assert False == array_tester.with_type(TypeKind.INVALID).test()


def test_variable_whose_type_ends_array_is_identified_as_array(array_tester):
    assert True == array_tester.with_smart_array_variable().test()


def test_unrelated_class_name_is_not_identified_as_smart_pointer():
    assert False == is_name_for_smart_pointer('NotSmartPointer')


def test_boost_smart_pointer_is_identified_as_smart_pointer():
    assert True == is_name_for_smart_pointer('boost::shared_ptr<int>')


def test_standard_smart_pointer_is_identified_as_smart_pointer():
    assert True == is_name_for_smart_pointer('std::unique_ptr<int>')


def test_smart_pointer_to_smart_pointer_is_identified_as_smart_pointer():
    to_test = 'std::unique_ptr<std::unique_ptr<int>>'
    assert True == is_name_for_smart_pointer(to_test)


def test_class_with_ptr_in_name_is_not_identified_as_smart_pointer():
    assert False == is_name_for_smart_pointer('Claptrap')


def test_vector_of_smart_pointers_is_not_identified_as_smart_pointer():
    to_test = 'std::vector<std::shared_ptr<int>>'
    assert False == is_name_for_smart_pointer(to_test)


@pytest.fixture
def interface_tester():
    return _InterfaceTester()


@pytest.fixture
def pointer_tester():
    return _PointerTester()


@pytest.fixture
def array_tester():
    return _ArrayTester()


class _InterfaceTester():
    def __init__(self):
        self.node = MagicMock()
        self.children = []
        self.node.get_children.return_value = self.children

    def with_pure_virtual_method(self):
        self._add_child(self._Node(is_method=True, is_pure_virtual=True))
        return self

    def with_virtual_method(self):
        self._add_child(self._Node(is_method=True, is_pure_virtual=False))
        return self

    def with_method(self):
        self._add_child(self._Node(is_method=True, is_pure_virtual=False))
        return self

    def with_unknown(self):
        self._add_child(self._Node(is_method=False, is_pure_virtual=False))
        return self

    def test(self):
        return is_interface_class(self.node)

    def _add_child(self, child):
        self.children.append(child)
        self.node.get_children.return_value = self.children

    class _Node:
        def __init__(self, is_method=True, is_pure_virtual=True):
            self.is_method = is_method
            self.is_pure_virtual = is_pure_virtual
            if is_method:
                self.kind = CursorKind.CXX_METHOD
            else:
                self.kind = CursorKind.VAR_DECL

        def is_pure_virtual_method(self):
            return self.is_pure_virtual


class _VariableTester():
    def __init__(self):
        self.node = MagicMock()
        self.with_type(TypeKind.INVALID)

    def with_kind(self, kind):
        self.node.kind = kind
        return self

    def with_type(self, type):
        self.node.type = MagicMock(kind=type)
        return self._set_array_types()

    def _set_array_types(self):
        if self.node.type.kind == TypeKind.CONSTANTARRAY:
            return self._set_array_element_type(TypeKind.INT)
        return self._set_array_element_type(TypeKind.INVALID)

    def _set_array_element_type(self, element_kind):
        array_element_type = MagicMock()
        self.node.type.get_array_element_type.return_value = array_element_type
        element_pointee_type = MagicMock(kind=element_kind)
        array_element_type.get_pointee.return_value = element_pointee_type
        return self

    def _set_type_name(self, name):
        canonical_type = MagicMock(spelling=name)
        self.node.type.get_canonical.return_value = canonical_type
        return self


class _PointerTester(_VariableTester):

    def with_smart_pointer_variable(self):
        self.with_kind(CursorKind.VAR_DECL)
        self.with_type(TypeKind.UNEXPOSED)
        self._set_type_name('std::shared_ptr<int>')
        return self._set_array_types()

    def with_typedef_smart_pointer_variable(self):
        self.with_kind(CursorKind.VAR_DECL)
        self.with_type(TypeKind.TYPEDEF)
        self._set_type_name('std::shared_ptr<int>')
        return self._set_array_types()

    def test(self):
        return is_pointer(self.node)


class _ArrayTester(_VariableTester):

    def with_smart_array_variable(self):
        self.with_kind(CursorKind.VAR_DECL)
        self.with_type(TypeKind.UNEXPOSED)
        self._set_type_name('boost::scoped_array<int>')
        return self._set_array_types()

    def test(self):
        return is_array(self.node)
