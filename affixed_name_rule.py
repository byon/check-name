# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from case_rules import is_camel_case, is_headless_camel_case
import rules


class AffixedNameRule:

    class AffixRule:
        def __init__(self, type_name, affix_type, identifier, condition):
            self._type_name = type_name
            self.affix_type = affix_type
            self.identifier = identifier
            self.condition = condition

        def test(self, node, affix):
            result = affix and self.identifier in affix
            if not self.condition(node):
                return not result
            return result

        def error_description(self, node):
            problem = 'missing'
            if not self.condition(node):
                problem = 'has redundant'
            return '{} {} "{}"'.format(problem, self.affix_type,
                                       self.identifier)

        def type_name(self, node):
            if self.condition(node):
                return self._type_name
            return 'non-' + self._type_name

    def __init__(self):
        self.errors = []
        self.prefix_rules = []
        self.postfix_rules = []

    def add_prefix_rule(self, type_name, prefix, condition):
        rule = self.AffixRule(type_name, 'prefix', prefix, condition)
        self.prefix_rules.append(rule)

    def add_postfix_rule(self, type_name, postfix, condition):
        rule = self.AffixRule(type_name, 'postfix', postfix, condition)
        self.postfix_rules.append(rule)

    def test(self, node):
        prefix_size = self._test_prefix(node)
        postfix_size = self._test_postfix(node)
        self._test_name(node, prefix_size, postfix_size)
        return self.errors

    def _test_prefix(self, node):
        return self._test_affix(node, _guess_prefix, self.prefix_rules)

    def _test_postfix(self, node):
        return self._test_affix(node, _guess_postfix, self.postfix_rules)

    def _test_affix(self, node, guess_affix, affixes):
        affix = guess_affix(node.spelling, _legal_affixes(affixes))
        for affix_rule in affixes:
            if not affix_rule.test(node, affix):
                self._add_error(node, affix_rule.error_description(node),
                                affix_rule.type_name(node))
        return len(affix)

    def _test_name(self, node, prefix_size, postfix_size):
        if not node.spelling:
            return
        end = -postfix_size if postfix_size > 0 else None
        to_test = node.spelling[prefix_size:end]
        if not to_test:
            self._add_error(node, 'missing name after prefix')
            return
        tester, case_type = _choose_case_tester(prefix_size)
        if not tester(to_test):
            self._add_error(node, 'is not in ' + case_type)

    def _add_error(self, node, description, type_name=None):
        type_name = type_name if type_name else 'variable'
        error = rules.Error(type_name, node.spelling, description)
        self.errors.append(error)


def _guess_prefix(name, legal_affixes):
    return _guess_affix(name, legal_affixes, str.isupper)


def _guess_postfix(name, legal_affixes):
    boundary = lambda c: not str.isupper(c)
    return _guess_affix(reversed(name), legal_affixes, boundary)


def _guess_affix(name_iterator, legal_affixes, boundary):
    result = ''
    for character in name_iterator:
        if boundary(character):
            return result
        if character not in legal_affixes:
            return ''
        result += character
    return result


def _legal_affixes(rule_list):
    return [r.identifier for r in rule_list]


def _choose_case_tester(prefix_size):
    if prefix_size == 0:
        return is_headless_camel_case, 'headlessCamelCase'
    return is_camel_case, 'CamelCase'
