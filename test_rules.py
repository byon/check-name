# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from clang.cindex import CursorKind, TypeKind
import rules
import pytest
from mock import MagicMock


def test_unidentified_node_will_have_no_rules(identify_rules_tester):
    assert not identify_rules_tester.test()


def test_namespace_should_have_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.NAMESPACE).test()
    assert rules.CamelCaseRule in _rule_types(result)


def test_variable_should_have_headless_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.VAR_DECL).test()
    assert rules.HeadlessCamelCaseRule in _rule_types(result)


def test_method_should_have_headless_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.CXX_METHOD).test()
    assert rules.HeadlessCamelCaseRule in _rule_types(result)


def test_function_should_have_headless_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.FUNCTION_DECL).test()
    assert rules.HeadlessCamelCaseRule in _rule_types(result)


def test_member_variable_should_have_headless_camel_case_rule(
        identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.FIELD_DECL).test()
    assert _rule_of_type(result, rules.HeadlessCamelCaseRule).postfix_size == 1


def test_member_variable_should_have_postfix_m_rule(
        identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.FIELD_DECL).test()
    assert _rule_of_type(result, rules.PostFixRule).postfix == 'M'


def test_reference_variable_should_have_prefix_r_rule(identify_rules_tester):
    result = identify_rules_tester.with_reference_variable().test()
    assert _rule_of_type(result, rules.PreFixRule).prefix == 'r'


def test_reference_member_should_have_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_reference_member().test()
    assert _rule_of_type(result, rules.CamelCaseRule).prefix_size == 1


def test_class_should_have_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.CLASS_DECL).test()
    assert rules.CamelCaseRule in _rule_types(result)


def test_struct_should_have_camel_case_rule(identify_rules_tester):
    result = identify_rules_tester.with_kind(CursorKind.STRUCT_DECL).test()
    assert rules.CamelCaseRule in _rule_types(result)


def test_interface_class_should_have_if_postfix(identify_rules_tester):
    result = identify_rules_tester.with_interface_class().test()
    assert _rule_of_type(result, rules.PostFixRule).postfix == 'If'


def test_identifying_class():
    result = rules.identify_rules_for_class(_Node(CursorKind.CLASS_DECL))
    assert rules.CamelCaseRule in _rule_types(result)


def test_construction_of_rule():
    test = MagicMock()
    rule = rules.Rule('identifier', 'description', test)
    assert rule.type_name == 'identifier'
    assert rule.errors == ['description']
    assert rule.rule_test == test


def test_noticing_rule_failure():
    test = MagicMock(return_value=False)
    assert False == rules.Rule('', '', test).test(_Node(name=''))


def test_noticing_rule_success():
    test = MagicMock(return_value=True)
    assert True == rules.Rule('', '', test).test(_Node(name=''))


def test_construction_of_conditional_rule():
    test = MagicMock()
    condition = MagicMock()
    rule = rules.ConditionalRule('identifier', 'original', 'inverted', test,
                                 condition)
    assert rule.type_name == 'identifier'
    assert rule.rule_test == test
    assert rule.original_description == 'original'
    assert rule.inverted_description == 'inverted'
    assert rule.condition == condition


def test_conditional_rule_test_is_not_inverted_by_default():
    test = MagicMock(return_value=True)
    rule = rules.ConditionalRule('', '', '', test)
    assert True == rule.test(_Node(name=''))


def test_conditional_rule_test_is_not_inverted_with_true_condition():
    test = MagicMock(return_value=True)
    rule = rules.ConditionalRule('', '', '', test, lambda _: True)
    assert True == rule.test(_Node(name=''))


def test_conditional_rule_test_is_inverted_with_false_condition():
    test = MagicMock(return_value=True)
    rule = rules.ConditionalRule('', '', '', test, lambda _: False)
    assert False == rule.test(_Node(name=''))


def test_conditional_rule_uses_original_description_for_true_condition():
    test = MagicMock(return_value=True)
    rule = rules.ConditionalRule('', 'original', '', test, lambda _: True)
    rule.test(_Node(name=''))
    assert ['original'] == rule.errors


def test_conditional_rule_uses_inverted_description_for_false_condition():
    test = MagicMock(return_value=True)
    rule = rules.ConditionalRule('', '', 'inverted', test, lambda _: False)
    rule.test(_Node(name=''))
    assert ['inverted'] == rule.errors


def test_construction_of_partial_check_rule():
    rule = rules.PartialCheckRule('', '', MagicMock(), 12, 34)
    assert 12 == rule.prefix_size
    assert 34 == rule.postfix_size


def test_partial_check_rule_will_not_check_pre_and_post_fixes():
    test = MagicMock()
    rule = rules.PartialCheckRule('', '', test, 3, 4)
    rule.test(_Node(name='preContentPost'))
    test.assert_called_once_with('Content')


def test_partial_check_rule_will_whole_content_when_sizes_are_zero():
    test = MagicMock()
    rule = rules.PartialCheckRule('', '', test, 0, 0)
    rule.test(_Node(name='preContentPost'))
    test.assert_called_once_with('preContentPost')


def test_construction_of_camel_case_rule():
    rule = rules.CamelCaseRule('identifier', 4321, 1234)
    assert 4321 == rule.prefix_size
    assert 1234 == rule.postfix_size


def test_construction_of_headless_camel_case_rule():
    rule = rules.HeadlessCamelCaseRule('identifier', 1234)
    assert 0 == rule.prefix_size
    assert 1234 == rule.postfix_size


def test_construction_of_postfix_rule():
    rule = rules.PostFixRule('identifier', 'postfix', MagicMock())
    assert rule.postfix == 'postfix'


def test_construction_of_prefix_rule():
    rule = rules.PreFixRule('identifier', 'prefix', MagicMock())
    assert rule.prefix == 'prefix'


def test_missing_postfix_is_failure():
    assert False == rules.PostFixRule('', 'P').test(_Node(name='name'))


def test_postfix_in_middle_is_failure():
    assert False == rules.PostFixRule('', 'P').test(_Node(name='naPme'))


def test_existing_postfix_is_success():
    assert True == rules.PostFixRule('', 'P').test(_Node(name='nameP'))


@pytest.fixture
def identify_rules_tester():
    return _IdentifyRulesTester()


class _Node:
    def __init__(self, kind=None, name=None):
        self.kind = MagicMock()
        self.kind.__eq__.side_effect = lambda k: k == kind
        self.spelling = name if name else ''
        self.pure_virtual_method = False
        self.children = []
        self.type = MagicMock()

    def add_child(self, child):
        self.children.append(child)

    def get_children(self):
        return self.children


class _Method(_Node):
    def __init__(self, virtual=False, pure_virtual=False, name=None):
        assert not pure_virtual or (pure_virtual and virtual)
        _Node.__init__(self, CursorKind.CXX_METHOD, name)
        self.virtual = virtual
        self.pure_virtual = pure_virtual

    def is_pure_virtual_method(self):
        return self.pure_virtual

    def is_virtual_method(self):
        return self.virtual


class _IdentifyRulesTester:
    def __init__(self):
        self.node = _Node()

    def test(self):
        return rules.identify_rules(self.node)

    def with_kind(self, kind):
        self.node = _Node(kind)
        return self

    def with_interface_class(self):
        self.node = _Node(CursorKind.CLASS_DECL)
        self.node.add_child(_Method(True, True))
        return self

    def with_reference_variable(self):
        self.node = _Node(CursorKind.VAR_DECL)
        self.node.type.kind = TypeKind.LVALUEREFERENCE
        return self

    def with_reference_member(self):
        self.node = _Node(CursorKind.FIELD_DECL)
        self.node.type.kind = TypeKind.LVALUEREFERENCE
        return self


def _rule_types(rules):
    return [r.__class__ for r in rules]


def _rule_of_type(rules, type):
    for rule in rules:
        if rule.__class__ == type:
            return rule
    assert False, 'Could not find type ' + type.__name__
